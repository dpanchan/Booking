mvnw and mvnw.cmd — These are Maven wrapper scripts. 
You can use these scripts to build your project even if you don’t have Maven installed on your machine.

pom.xml—This is the Maven build specification. 

BookingApplication.java—
This is the Spring Boot main class that bootstraps the project.

application.properties—
This file is initially empty, but offers a place where you can specify configuration properties. 

BookingApplicationTests.java—This is a simple test class that ensures that the Spring application context loads successfully. 
You’ll add more tests to the mix as you develop the application.

Install lombok jar on your machine and place it in m2 lib

you can add dozer and auto wire it


The save() method doesn’t actually save anything. It defines the flow for saving an Order and its associated Taco objects, and delegates the persistence work to saveOrderDetails() and saveTacoToOrder().


Using ObjectMapper to map an object into a Map is much easier than copying each property from the object into the Map. Feel free to replace the use of ObjectMapper with any code you prefer that builds the Map you’ll give to the inserter objects.

In order to declare this as a JPA entity, Ingredient must be annotated with @Entity. And its id property must be annotated with @Id to designate it as the property that will uniquely identify the entity in the database.
	
Booking bd = new DozerBeanMapper().map(b, Booking.class); // b is request entity and bd is the db entity



n addition to an implicit Equals operation and the Between operation, Spring Data method signatures can also include any of these operators:

IsAfter, After, IsGreaterThan, GreaterThan
IsGreaterThanEqual, GreaterThanEqual
IsBefore, Before, IsLessThan, LessThan
IsLessThanEqual, LessThanEqual
IsBetween, Between
IsNull, Null
IsNotNull, NotNull
IsIn, In
IsNotIn, NotIn
IsStartingWith, StartingWith, StartsWith
IsEndingWith, EndingWith, EndsWith
IsContaining, Containing, Contains
IsLike, Like
IsNotLike, NotLike
IsTrue, True
IsFalse, False
Is, Equals
IsNot, Not
IgnoringCase, IgnoresCase

When the application starts, autoconfiguration will detect that Spring Security is in the classpath and will set up some basic security configuration.

Just add security dependency to pom and run application.....open home page localhost:port/ , you will get auth page, no other changes needed

The @RestController annotation serves two purposes. First, it’s a stereotype annotation like @Controller and @Service that marks a class for discovery by component scanning. 

@PostMapping(consumes="application/json")
@ResponseStatus(HttpStatus.CREATED)
public Taco postTaco(@RequestBody Taco taco) {
  return tacoRepo.save(taco);
}

@DeleteMapping("/{orderId}")
@ResponseStatus(code=HttpStatus.NO_CONTENT)
public void deleteOrder(@PathVariable("orderId") Long orderId) {
  try {
    repo.deleteById(orderId);
  } catch (EmptyResultDataAccessException e) {}
}


There’s more than one way to PATCH
The patching approach applied in the patchOrder() method has a couple of limitations:

If null values are meant to specify no change, how can the client indicate that a field should be set to null?
There’s no way of removing or adding a subset of items from a collection. If the client wants to add or remove an entry from a collection, it must send the complete altered collection.

@GetMapping("/recent")
public Resources<TacoResource> recentTacos() {
  PageRequest page = PageRequest.of(
          0, 12, Sort.by("createdAt").descending());
  List<Taco> tacos = tacoRepo.findAll(page).getContent();

  List<TacoResource> tacoResources =
      new TacoResourceAssembler().toResources(tacos);
  Resources<TacoResource> recentResources =
      new Resources<TacoResource>(tacoResources);
  recentResources.add(
      linkTo(methodOn(DesignTacoController.class).recentTacos())
      .withRel("recents"));
  return recentResources;
}

Spring Data REST is another member of the Spring Data family that automatically creates REST APIs for repositories created by Spring Data. By doing little more than adding Spring Data REST to your build, you get an API with operations for each repository interface you’ve defined.

To start using Spring Data REST, you add the following dependency to your build:

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-rest</artifactId>
</dependency>
Believe it or not, that’s all that’s required to expose a REST API in a project that’s already using Spring Data for automatic repositories. By simply having the Spring Data REST starter in the build, the application gets auto-configuration that enables automatic creation of a REST API for any repositories that were created by Spring Data (including Spring Data JPA, Spring Data Mongo, and so on).

$ curl "localhost:8080/api/tacos?sort=createdAt,desc&page=0&size=12"






